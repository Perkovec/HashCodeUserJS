Формат аддона в виде объекта:  

    {
        name: 'sortBetter', // уникальное имя, которое идентифицирует аддон
        
        title: 'Улучшенная сортировка', // Имя для отображения, может содержать разметку
        
        description: 'Сортирует по актуальности', // Описание. Может содержать разметку
        
        run: function(){}, // основное тело аддона, функция, которая будет запущена
        
        settings: {
            orderBy: 'title'
        }, // настройки, объект JavaScript. При сохранении будет сериальзован и сохранен в localStorage. Изначально этот объект хранит настройки по-умолчанию. Перед run, в него будут внесены данные из localStorage. Если предполагается хранить большие объемы данных, то лучше напрямую работать с localStorage.
        
        exports: [
            {name:'orderBy', type:'text', title:'Порядок сортировки'},
            {name:'country', type:'select', title:'Ваш город', options:{'1':'Даллас', '2':'Вегас'} },
            {name:'biograph', type:'area', title:'Ваша биография', options:{rows:5}}
        ], // упорядоченный массив, если не задан drawer, то элементы будут отображены в порядке следования в массиве. name должно совпадать с ключом из settings. type допустим из: [text, checkbox, select, radio, hidden, textarea]. Для select и radio options содержит массив ключ- выставляемое значение, значение- заголовок. Для textarea это rows, который содержит количество строк. Все настройки из exports переносятся между проектами Сети Знаний по нажатию "Сохранить", если нужна переносимая настройка, которую не должен менять пользователь, то используйте тип hidden. Тип checkbox переключает значения 0 и 1.
        
        drawer: function(targetNode) {}, // в эту функцию поступает элемент внутри которого надо отрисовать блок настроек аддона, необходимо учитывать, что в этом блоке уже могут быть данные (например кнопка закрытия). Можно не задавать отрисовщик- будет применен отрисовщик по умолчанию. Отрисовщик вызывается только один раз для наполнения блока, если блок уже наполнен, то вызова не будет. Отрисовщик вызывается при клике пользователем на элементе списка аддонов.
        
        namesResolver: function(name) {
            return this.name+"_setting_"+name;
        }, // создает уникальное имя для настройки (name - настройка из settings), лучше не определять самому, namesResolver будет установлен перед вызовом drawer в значение по-умолчанию (как здесь приведено). В своем drawer для задания имени элементу нужно использовать результат вызова namesResolver
        
        saveSettings: function() {
            window.addonsLoader.storage[this.name]=this.settings;
            window.addonsLoader.saveStorage();
        }, // эта функция будет доступна в контексте this аддона, переопределять ее бесполезно
        
        beforeInit: function(){}, // эта функция вызывается перед запуском addonsLoader.init сразу в момент внедрения кода загрузчика в тело страницы, поэтому весьма вероятно, что на этот момент может быть не определен $ и не создана полностью DOM-модель документа
        
        beforeDraw: function(){}, // эта функция вызывается перед началом отрисовки блока настроек
        
        afterDraw: function(){}, // эта функция вызывается после окончания отрисовки блока настроек
        
        afterInit: function(){} // эта функция вызывается, когда addonsLoader.init закончил свою работу
    }      

Если регулярные выражения содержат кириллицу, или другие национальные символы, то они не должны иметь вид:  

    var regex= /test тест/;
Такие регулярные выражения для переносимости между браузерами должны быть созданы как новый объект:  

    var regex= new RegExp("test тест");

Все глобальные функции  и переменные должны начинаться с двух знаков подчеркивания:  

    function __example()

Комментарии к коду на русском языке.  

Для вынесения изображений (которые хранятся в data-url) за  пределы кода необходимо скрывать их data-url за псевдотэгом:  

    <img src='[DEPLOY:image64]images/path.png[/DEPLOY]'>
При этом `images/path.png` этот путь к изображению в репозитории.  

Если функция не сможет работать или бесполезна на каком-то из проектов Сети Знаний", то она должна проверять `location`, дабы не быть задействованной где не надо.  

Каждый аддон представляет собой один файл в папке addons, они должны быть  написаны с учетом того, что их код будет объединяться с кодом userjsloader путем помещения кода аддонов в упорядоченный массив.  
    
Редактировать новые аддоны можно в окне браузера, включив "Режим разработчика". В pull request необходимо включить код объекта-аддона сохраненный в кодировке UTF-8+BOM. Сборки релизов под разные браузеры производятся автоматически отдельным коммитом.

